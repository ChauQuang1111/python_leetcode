# // // 407. Trapping Rain Water II(03/10/2025)
# R·∫•t hay üëç. B·∫°n ƒë√£ vi·∫øt l·ªùi gi·∫£i b·∫±ng **BFS + Min-Heap** cho b√†i **Trapping Rain Water II (LeetCode 407)**. M√¨nh s·∫Ω gi·∫£i th√≠ch chi ti·∫øt thu·∫≠t to√°n v√† th√™m ch√∫ th√≠ch v√†o code c·ªßa b·∫°n.

# ---

# ## üîë √ù t∆∞·ªüng thu·∫≠t to√°n:

# 1. **N∆∞·ªõc lu√¥n b·ªã gi·ªØ l·∫°i b·ªüi c√°c r√†o ch·∫Øn th·∫•p nh·∫•t ·ªü bi√™n ngo√†i.**
#    ‚Üí V√¨ th·∫ø ta b·∫Øt ƒë·∫ßu t·ª´ **bi√™n (boundary)** v√† ti·∫øn d·∫ßn v√†o trong.

# 2. **D√πng min-heap (priority queue):**

#    * Lu√¥n l·∫•y √¥ c√≥ ƒë·ªô cao nh·ªè nh·∫•t ·ªü bi√™n hi·ªán t·∫°i.
#    * ƒêi·ªÅu n√†y ƒë·∫£m b·∫£o khi ta duy·ªát v√†o trong, ta bi·∫øt m·ª±c "r√†o ch·∫Øn" th·∫•p nh·∫•t bao quanh n√≥.

# 3. **BFS m·ªü r·ªông:**

#    * L·∫•y √¥ th·∫•p nh·∫•t t·ª´ heap ra.
#    * Duy·ªát c√°c √¥ k·ªÅ.
#    * N·∫øu √¥ k·ªÅ th·∫•p h∆°n r√†o ch·∫Øn hi·ªán t·∫°i, th√¨ **n∆∞·ªõc s·∫Ω b·ªã gi·ªØ l·∫°i**.
#    * ƒê∆∞a √¥ k·ªÅ v√†o heap v·ªõi chi·ªÅu cao = `max(r√†o ch·∫Øn, chi·ªÅu cao √¥ k·ªÅ)` (v√¨ n∆∞·ªõc c√≥ th·ªÉ d√¢ng l√™n b·∫±ng r√†o ch·∫Øn).

# 4. **L·∫∑p l·∫°i cho ƒë·∫øn khi heap r·ªóng.**

# ---

# ## üìå Code c√≥ ch√∫ th√≠ch:

# ```python

import heapq
from typing import List

class Solution:
    def trapRainWater(self, heightMap: List[List[int]]) -> int:
        heap = []

        m = len(heightMap)
        n = len(heightMap[0])

        # visited[i][j] = True n·∫øu √¥ (i,j) ƒë√£ x·ª≠ l√Ω
        visited = [[False for _ in range(n)] for _ in range(m)]

        # 1. ƒê∆∞a t·∫•t c·∫£ c√°c √¥ bi√™n v√†o heap tr∆∞·ªõc (ch√∫ng l√† "r√†o ch·∫Øn" ban ƒë·∫ßu)
        for i in range(m):
            for j in range(n):
                if i == 0 or i == m - 1 or j == 0 or j == n - 1:
                    heapq.heappush(heap, (heightMap[i][j], i, j))
                    visited[i][j] = True

        # 4 h∆∞·ªõng ƒëi (tr√°i, ph·∫£i, tr√™n, d∆∞·ªõi)
        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]

        trapped_water = 0

        # 2. BFS m·ªü r·ªông t·ª´ bi√™n v√†o trong
        while heap:
            height, i, j = heapq.heappop(heap)  # √¥ c√≥ chi·ªÅu cao nh·ªè nh·∫•t hi·ªán t·∫°i

            # 3. Duy·ªát c√°c √¥ k·ªÅ
            for dx, dy in directions:
                newX, newY = i + dx, j + dy
                # ch·ªâ x√©t c√°c √¥ trong ph·∫°m vi v√† ch∆∞a ƒë∆∞·ª£c thƒÉm
                if 0 <= newX < m and 0 <= newY < n and not visited[newX][newY]:
                    visited[newX][newY] = True
                    cell_height = heightMap[newX][newY]

                    if cell_height < height:
                        # N·∫øu √¥ th·∫•p h∆°n r√†o ch·∫Øn ‚Üí gi·ªØ n∆∞·ªõc
                        trapped_water += height - cell_height
                        # ƒê∆∞a √¥ n√†y v√†o heap v·ªõi chi·ªÅu cao b·∫±ng r√†o ch·∫Øn hi·ªán t·∫°i
                        heapq.heappush(heap, (height, newX, newY))
                    else:
                        # N·∫øu √¥ cao h∆°n ‚Üí n√≥ tr·ªü th√†nh r√†o ch·∫Øn m·ªõi
                        heapq.heappush(heap, (cell_height, newX, newY))

        return trapped_water
# ```

# ---

# ## üîé V√≠ d·ª• minh h·ªça:

# ```
# heightMap = [
#   [1,4,3,1,3,2],
#   [3,2,1,3,2,4],
#   [2,3,3,2,3,1]
# ]
# ```

# * C√°c bi√™n (1,4,3,1,3,2,...) ƒë∆∞·ª£c ƒë∆∞a v√†o heap.
# * B·∫Øt ƒë·∫ßu t·ª´ √¥ bi√™n th·∫•p nh·∫•t ‚Üí m·ªü r·ªông v√†o trong.
# * Khi g·∫∑p √¥ (1,2)=1, n√≥ b·ªã bao quanh b·ªüi r√†o ch·∫Øn cao h∆°n (min=3),
#   ‚Üí gi·ªØ ƒë∆∞·ª£c `3-1 = 2` ƒë∆°n v·ªã n∆∞·ªõc.

# ---

# üëâ T√≥m l·∫°i:

# * **Heap ƒë·∫£m b·∫£o ta lu√¥n m·ªü r·ªông t·ª´ √¥ th·∫•p nh·∫•t.**
# * **N∆∞·ªõc gi·ªØ ƒë∆∞·ª£c ph·ª• thu·ªôc v√†o r√†o ch·∫Øn th·∫•p nh·∫•t.**
# * **Khi g·∫∑p √¥ th·∫•p h∆°n r√†o ch·∫Øn, n∆∞·ªõc ƒë∆∞·ª£c c·ªông d·ªìn.**

# ---

# B·∫°n c√≥ mu·ªën m√¨nh v·∫Ω **h√¨nh minh h·ªça tr·ª±c quan (b·∫±ng ASCII ho·∫∑c ·∫£nh)** cho v√≠ d·ª• nh·ªè ƒë·ªÉ d·ªÖ h√¨nh dung h∆°n c√°ch n∆∞·ªõc b·ªã gi·ªØ l·∫°i kh√¥ng?

# import java.util.*;

# public class b56 {
#     static Scanner sc = new Scanner(System.in);

#     public static void main(String[] args) {
#         int m = sc.nextInt();
#         int n = sc.nextInt();

#         int[][] heightMap = new int[m][n];
#         for (int i = 0; i < m; i++) {
#             for (int j = 0; j < n; j++) {
#                 heightMap[i][j] = sc.nextInt();
#             }
#         }

#         int result = trapRainWater(heightMap);
#         System.out.println(result);

#         sc.close();
#     }

#     public static int trapRainWater(int[][] heightMap) {
#         int m = heightMap.length; // s·ªë h√†ng
#         int n = heightMap[0].length; // s·ªë c·ªôt

#         // M·∫£ng vols l∆∞u l·∫°i "m·ª±c n∆∞·ªõc c√≥ th·ªÉ ch·ª©a" t·∫°i t·ª´ng √¥
#         // Ban ƒë·∫ßu g√°n = heightMap (nghƒ©a l√† ch∆∞a c√≥ n∆∞·ªõc th√™m)
#         int[][] vols = new int[m][n];
#         for (int i = 0; i < m; i++) {
#             for (int j = 0; j < n; j++) {
#                 vols[i][j] = heightMap[i][j];
#             }
#         }

#         boolean upt = true; // c·ªù ki·ªÉm tra c√≥ c·∫≠p nh·∫≠t m·ª±c n∆∞·ªõc kh√¥ng
#         boolean init = true; // l·∫ßn qu√©t ƒë·∫ßu ti√™n cho ph√©p c·∫≠p nh·∫≠t h·∫øt

#         // L·∫∑p l·∫°i cho ƒë·∫øn khi kh√¥ng c√≤n c·∫≠p nh·∫≠t n·ªØa
#         while (upt) {
#             upt = false;

#             // Qu√©t t·ª´ tr√™n tr√°i xu·ªëng d∆∞·ªõi ph·∫£i
#             for (int i = 1; i < m - 1; i++) {
#                 for (int j = 1; j < n - 1; j++) {
#                     // M·ª±c n∆∞·ªõc t·∫°i √¥ (i,j) kh√¥ng th·ªÉ th·∫•p h∆°n chi·ªÅu cao g·ªëc heightMap[i][j]
#                     // v√† c≈©ng b·ªã gi·ªõi h·∫°n b·ªüi n∆∞·ªõc t·ª´ ph√≠a tr√™n (i-1,j) ho·∫∑c b√™n tr√°i (i,j-1)
#                     int val = Math.max(heightMap[i][j],
#                             Math.min(vols[i - 1][j], vols[i][j - 1]));

#                     // N·∫øu l√† l·∫ßn ƒë·∫ßu init, ho·∫∑c c√≥ th·ªÉ h·∫° th·∫•p m·ª©c n∆∞·ªõc hi·ªán t·∫°i
#                     if (init || vols[i][j] > val) {
#                         vols[i][j] = val; // c·∫≠p nh·∫≠t m·ª±c n∆∞·ªõc t·∫°i √¥ (i,j)
#                         upt = true; // ƒë√°nh d·∫•u c√≥ thay ƒë·ªïi
#                     }
#                 }
#             }
#             init = false; // sau l·∫ßn qu√©t ƒë·∫ßu th√¨ t·∫Øt init

#             // Qu√©t t·ª´ d∆∞·ªõi ph·∫£i l√™n tr√™n tr√°i
#             for (int i = m - 2; i >= 1; i--) {
#                 for (int j = n - 2; j >= 1; j--) {
#                     // T∆∞∆°ng t·ª± nh∆∞ng x√©t h√†ng x√≥m ph√≠a d∆∞·ªõi (i+1,j) v√† ph·∫£i (i,j+1)
#                     int val = Math.max(heightMap[i][j],
#                             Math.min(vols[i + 1][j], vols[i][j + 1]));

#                     // N·∫øu m·ª©c n∆∞·ªõc hi·ªán t·∫°i cao h∆°n m·ª©c h·ª£p l√Ω, h·∫° xu·ªëng
#                     if (vols[i][j] > val) {
#                         vols[i][j] = val;
#                         upt = true;
#                     }
#                 }
#             }
#         }

#         // T√≠nh t·ªïng l∆∞·ª£ng n∆∞·ªõc = (m·ª±c n∆∞·ªõc - chi·ªÅu cao ƒë·∫•t)
#         int res = 0;
#         for (int i = 1; i < m - 1; i++) {
#             for (int j = 1; j < n - 1; j++) {
#                 if (vols[i][j] > heightMap[i][j]) {
#                     res += vols[i][j] - heightMap[i][j];
#                 }
#             }
#         }
#         return res;
#     }

# }

# // Ok b√†i**407.
# // Trapping Rain
# // Water II**
# // kh√° hayüòÉ
# // N√≥ l√†
# // phi√™n b·∫£n

# // n√¢ng cao (2D) c·ªßa b√†i **Trapping Rain Water (1D)**.

# // ---

# // ## üö∞ ƒê·ªÅ b√†i t√≥m t·∫Øt

# // * Cho m·ªôt ma tr·∫≠n `heightMap` (m √ó n), m·ªói √¥ l√† chi·ªÅu cao c·ªôt t∆∞·ªùng.
# // * N∆∞·ªõc m∆∞a c√≥ th·ªÉ b·ªã gi·ªØ l·∫°i trong c√°c ‚Äúh·ªë‚Äù

# // b√™n trong (gi·ªØa c√°c t∆∞·ªùng cao).
# // * H√£y t√≠nh t·ªïng l∆∞·ª£ng n∆∞·ªõc t·ªëi ƒëa c√≥ th·ªÉ gi·ªØ.

# // ---

# // ## üí° √ù t∆∞·ªüng thu·∫≠t to√°n

# // N·∫øu b·∫°n ƒë√£ h·ªçc b√†i **Trapping Rain Water (1D)** th√¨ c√°ch t∆∞ duy kh√° gi·ªëng:

# // * ·ªû 1D: ƒë·ªÉ bi·∫øt n∆∞·ªõc t·∫°i 1 v·ªã tr√≠, ta c·∫ßn bi·∫øt **max chi·ªÅu cao b√™n tr√°i** v√†
# // **max chi·ªÅu cao b√™n ph·∫£i**.
# // * ·ªû 2D: t·∫°i 1 √¥ `(i, j)`, l∆∞·ª£ng n∆∞·ªõc gi·ªØ ƒë∆∞·ª£c ph·ª• thu·ªôc v√†o **t∆∞·ªùng th·∫•p nh·∫•t
# // bao quanh n√≥**.

# // ---

# // ## üîë Thu·∫≠t to√°n

# // chi ti·∫øt (d√πng BFS + Min-Heap)

# // 1. **Kh·ªüi t·∫°o h√†ng r√†o**:

# // * N∆∞·ªõc ch·ªâ c√≥ th·ªÉ b·ªã gi·ªØ b√™n trong, kh√¥ng th·ªÉ v∆∞·ª£t qua bi√™n.
# // * Th√™m t·∫•t c·∫£ c√°c

# // √¥ bi√™n (boundary cells) v√†o **min-heap**, coi nh∆∞ b·ª©c t∆∞·ªùng bao ngo√†i.

# // 2. **BFS m·ªü r·ªông v√†o trong**:

# // * Lu√¥n l·∫•y ra √¥ **th·∫•p nh·∫•t**

# // t·ª´ heap (g·ªçi l√† `cell`).
# // * Duy·ªát 4 h∆∞·ªõng (l√™n, xu·ªëng, tr√°i, ph·∫£i).
# // * N·∫øu g·∫∑p √¥ l√°ng gi·ªÅng `next`:

# // * N·∫øu `height[next] < height[cell]` ‚Üí ch·ªó n√†y c√≥ th·ªÉ ch·ª©a n∆∞·ªõc:

# // ```
# // water += height[cell] - height[next]
# // ```
# // * C·∫≠p nh·∫≠t chi·ªÅu cao c·ªßa `next`:

# // ```
# // newHeight = max(height[next], height[cell])
# // ```

# // (v√¨ n∆∞·ªõc l·∫•p ƒë·∫ßy ƒë·∫øn t∆∞·ªùng th·∫•p nh·∫•t).
# // * Th√™m `next` v√†o heap v·ªõi `newHeight`.

# // 3. **L·∫∑p ƒë·∫øn khi heap r·ªóng**:

# // * Khi duy·ªát xong t·∫•t c·∫£, t·ªïng `water` ch√≠nh l√† k·∫øt qu·∫£.

# // ---

# // ## üìä ƒê·ªô ph·ª©c t·∫°p

# // * S·ª≠ d·ª•ng min-heap ch·ª©a t·ªëi ƒëa `m * n` ph·∫ßn t·ª≠.
# // * M·ªói √¥ v√†o heap ƒë√∫ng 1 l·∫ßn.
# // * ƒê·ªô ph·ª©c t·∫°p:

# // * **Th·ªùi gian**: `O(m * n * log(m*n))`
# // * **Kh√¥ng gian**: `O(m * n)`

# // ---

# // ## üåä V√≠ d·ª•

# // ```
# // heightMap =
# // [
# // [1,4,3,1,3,2],
# // [3,2,1,3,2,4],
# // [2,3,3,2,3,1]
# // ]
# // ```

# // * Ban ƒë·∫ßu l·∫•y bi√™n l√†m r√†o ch·∫Øn.
# // * T·ª´ bi√™n th·∫•p nh·∫•t, l·∫•p d·∫ßn v√†o trong.
# // * K·∫øt qu·∫£ cu·ªëi c√πng = **4 ƒë∆°n v·ªã n∆∞·ªõc**.

# // ---

# // üëâ B·∫°n c√≥ mu·ªën m√¨nh vi·∫øt h·∫≥n code Java c√≥ ch√∫ th√≠ch chi ti·∫øt cho thu·∫≠t to√°n
# // n√†y kh√¥ng?
# // Ok üëç ƒë·ªÉ m√¨nh gi·∫£i th√≠ch thu·∫≠t to√°n c·ªßa b·∫°n nh√©. ƒê√¢y l√† m·ªôt c√°ch gi·∫£i b√†i
# // **Trapping Rain

# // Water II (LeetCode 407)**.

# // ---

# // ## √ù t∆∞·ªüng thu·∫≠t to√°n

# // * B√†i to√°n y√™u c·∫ßu t√≠nh **l∆∞·ª£ng n∆∞·ªõc m∆∞a b·ªã gi·ªØ l·∫°i** tr√™n m·ªôt b·∫£n ƒë·ªì 2D
# // `heightMap`.
# // * N∆∞·ªõc b·ªã gi·ªØ l·∫°i khi **xung quanh √¥ ƒë√≥ cao h∆°n** v√† n∆∞·ªõc kh√¥ng tho√°t ra
# // ngo√†i bi√™n.
# // * Thu·∫≠t to√°n c·ªßa b·∫°n d√πng c√°ch **l·∫∑p c·∫≠p nh·∫≠t (relaxation)** ƒë·ªÉ t√¨m ra m·ª±c
# // n∆∞·ªõc t·ªëi ƒëa c√≥ th·ªÉ gi·ªØ t·∫°i m·ªói √¥.

# // ---

# // ## C√°c b∆∞·ªõc ch√≠nh

# // ### 1. Kh·ªüi t·∫°o

# // ```java
# // int[][] vols = new int[m][n];
# // for (int i = 0; i < m; i++) {
# // for (int j = 0; j < n; j++) {
# // vols[i][j] = heightMap[i][j];
# // }
# // }
# // ```

# // üëâ `vols[i][j]` ban ƒë·∫ßu l∆∞u **m·ª±c n∆∞·ªõc t·ªëi ƒëa** t·∫°i √¥ `(i, j)` = chi·ªÅu cao
# // g·ªëc.

# // ---

# // ### 2. C·∫≠p nh·∫≠t

# // d·∫ßn d·∫ßn (relaxation)

# // ```java
# // boolean upt = true;
# // boolean init = true;
# // while (upt) {
# // upt = false;
# // // Qu√©t t·ª´ tr√™n tr√°i xu·ªëng d∆∞·ªõi ph·∫£i
# // for (int i = 1; i < m - 1; i++) {
# // for (int j = 1; j < n - 1; j++) {
# // int val = Math.max(heightMap[i][j],
# // Math.min(vols[i - 1][j], vols[i][j - 1]));
# // if (init || vols[i][j] > val) {
# // vols[i][j] = val;
# // upt = true;
# // }
# // }
# // }
# // init = false;

# // // Qu√©t t·ª´ d∆∞·ªõi ph·∫£i l√™n tr√™n tr√°i
# // for (int i = m - 2; i >= 1; i--) {
# // for (int j = n - 2; j >= 1; j--) {
# // int val = Math.max(heightMap[i][j],
# // Math.min(vols[i + 1][j], vols[i][j + 1]));
# // if (vols[i][j] > val) {
# // vols[i][j] = val;
# // upt = true;
# // }
# // }
# // }
# // }
# // ```

# // üëâ √ù nghƒ©a:

# // * `vols[i][j]` = m·ª±c n∆∞·ªõc cao nh·∫•t c√≥ th·ªÉ gi·ªØ ƒë∆∞·ª£c t·∫°i √¥ `(i, j)`.
# // * Khi qu√©t, b·∫°n l·∫•y:

# // * `heightMap[i][j]`: m·∫∑t ƒë·∫•t th·∫≠t.
# // * `Math.min(vols[x][y], vols[u][v])`: gi·ªõi h·∫°n t·ª´ √¥ l√¢n c·∫≠n.
# // * `Math.max(...)`: ƒë·∫£m b·∫£o m·ª±c n∆∞·ªõc ‚â• m·∫∑t ƒë·∫•t.
# // * L·∫∑p t·ªõi khi **kh√¥ng c√≤n c·∫≠p nh·∫≠t** (`upt == false`).

# // N√≥i c√°ch kh√°c, b·∫°n ƒëang **lan truy·ªÅn r√†ng bu·ªôc v·ªÅ m·ª±c n∆∞·ªõc t·ª´ bi√™n v√†o
# // trong**.

# // ---

# // ### 3. T√≠nh k·∫øt qu·∫£

# // ```java
# // int res = 0;
# // for (int i = 1; i < m - 1; i++) {
# // for (int j = 1; j < n - 1; j++) {
# // if (vols[i][j] > heightMap[i][j])
# // res += vols[i][j] - heightMap[i][j];
# // }
# // }
# // return res;
# // ```

# // üëâ V·ªõi m·ªói √¥, l∆∞·ª£ng n∆∞·ªõc gi·ªØ ƒë∆∞·ª£c = `vols[i][j] - heightMap[i][j]`.

# // ---

# // ## ƒê·ªô ph·ª©c t·∫°p

# // * **Th·ªùi gian**:
# // V√≤ng `while` c√≥ th·ªÉ ch·∫°y nhi·ªÅu

# // l·∫ßn (ƒë·∫øn khi kh√¥ng thay ƒë·ªïi n·ªØa).
# // M·ªói l·∫ßn qu√©t m·∫•t `O(m*n)`.
# // ‚Üí Tr∆∞·ªùng h·ª£p x·∫•u c√≥ th·ªÉ kh√° ch·∫≠m (g·∫ßn `O((m*n)^2)`).

# // * **B·ªô nh·ªõ**: `O(m*n)` cho m·∫£ng `vols`.

# // ---

# // ## So s√°nh v·ªõi c√°ch t·ªëi ∆∞u

# // Thu·∫≠t to√°n chu·∫©n c·ªßa b√†i n√†y d√πng **Priority Queue (min-heap)**:

# // * B·∫Øt ƒë·∫ßu

# // t·ª´ bi√™n (bi√™n kh√¥ng gi·ªØ ƒë∆∞·ª£c n∆∞·ªõc).
# // * M·ªü r·ªông v√†o trong b·∫±ng BFS/heap, lu√¥n l·∫•y √¥ th·∫•p nh·∫•t.
# // * ƒê·∫£m b·∫£o ch·∫°y **O(m*n log(m*n))**.

# // Thu·∫≠t to√°n c·ªßa b·∫°n tuy ch·∫≠m h∆°n nh∆∞ng **tr·ª±c quan**:

# // * N√≥ gi·ªëng nh∆∞ vi·ªác **gi·∫£ s·ª≠ m·ª±c n∆∞·ªõc cao**, r·ªìi d·∫ßn d·∫ßn ‚Äúx·∫£‚Äù xu·ªëng khi th·∫•y
# // th·∫•p h∆°n t·ª´ bi√™n ‚Üí cu·ªëi c√πng t√¨m ƒë∆∞·ª£c m·ª©c ·ªïn ƒë·ªãnh.

# // ---

# // üëâ T√≥m l·∫°i:
# // Thu·∫≠t to√°n = **iterative relaxation**: c·∫≠p nh·∫≠t m·ª±c n∆∞·ªõc t·ª´ bi√™n v√†o trong,
# // l·∫∑p cho ƒë·∫øn khi ·ªïn ƒë·ªãnh.

# // ---

# // B·∫°n c√≥ mu·ªën m√¨nh vi·∫øt l·∫°i **c√°ch gi·∫£i b·∫±ng Priority Queue** (t·ªëi ∆∞u h∆°n,
# // th∆∞·ªùng g·∫∑p trong LeetCode) ƒë·ªÉ b·∫°n so s√°nh kh√¥ng?
