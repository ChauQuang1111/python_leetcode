# 3459. Length of Longest V-Shaped Diagonal Segment(27/08/2025)
import functools
from typing import List

class Solution:
    def lenOfVDiagonal(self, grid: List[List[int]]) -> int:
        # 4 h∆∞·ªõng ch√©o
        dirs = [(1, 1), (1, -1), (-1, -1), (-1, 1)]
        n = len(grid)     # s·ªë h√†ng
        m = len(grid[0])  # s·ªë c·ªôt

        # B·∫£ng √°nh x·∫° gi√° tr·ªã k·∫ø ti·∫øp c·∫ßn c√≥
        # grid[x][y] = 1 => c·∫ßn 2
        # grid[x][y] = 2 => c·∫ßn 1
        # nv[v] cho ta gi√° tr·ªã ti·∫øp theo mong mu·ªën
        nv = [2, 2, 0]

        @functools.cache
        # @functools.cache l√† m·ªôt decorator trong Python. N√≥ gi√∫p b·∫°n t·ªëi ∆∞u h√≥a c√°c h√†m ƒë·ªá quy ho·∫∑c c√°c h√†m t·ªën th·ªùi gian b·∫±ng c√°ch 
        # l∆∞u tr·ªØ k·∫øt qu·∫£ c·ªßa c√°c l·∫ßn g·ªçi h√†m tr∆∞·ªõc ƒë√≥. K·ªπ thu·∫≠t n√†y ƒë∆∞·ª£c g·ªçi l√† memoization
        def helper(x, y, turned, dir):
           
            # DFS + ghi nh·ªõ
            # x, y    : v·ªã tr√≠ hi·ªán t·∫°i
            # turned  : ƒë√£ r·∫Ω h∆∞·ªõng 1 l·∫ßn ch∆∞a (True/False)
            # dir     : h∆∞·ªõng hi·ªán t·∫°i (0..3)
            # Tr·∫£ v·ªÅ ƒë·ªô d√†i ƒë∆∞·ªùng ch√©o d√†i nh·∫•t b·∫Øt ƒë·∫ßu t·ª´ (x,y)
            
            res = 1  # √≠t nh·∫•t l·∫•y ƒë∆∞·ª£c √¥ (x,y)
            dx, dy = dirs[dir]

            # --- 1. Ti·∫øp t·ª•c ƒëi th·∫≥ng theo c√πng h∆∞·ªõng ---
            if (0 <= x + dx < n and 0 <= y + dy < m 
                and grid[x + dx][y + dy] == nv[grid[x][y]]):
                res = helper(x + dx, y + dy, turned, dir) + 1

            # --- 2. N·∫øu ch∆∞a r·∫Ω, th·ª≠ r·∫Ω sang h∆∞·ªõng ti·∫øp theo (90¬∞) ---
            if not turned:
                ndir = (dir + 1) % 4  # quay sang h∆∞·ªõng k·∫ø ti·∫øp
                dx, dy = dirs[ndir]
                if (0 <= x + dx < n and 0 <= y + dy < m 
                    and grid[x + dx][y + dy] == nv[grid[x][y]]):
                    res = max(res, helper(x + dx, y + dy, True, ndir) + 1)

            return res

        ans = 0
        for i in range(n):
            for j in range(m):
                if grid[i][j] == 1:  # ch·ªâ b·∫Øt ƒë·∫ßu t·ª´ √¥ c√≥ gi√° tr·ªã 1
                    # ∆∞·ªõc l∆∞·ª£ng t·ªëi ƒëa c√≥ th·ªÉ ƒëi theo m·ªói h∆∞·ªõng
                    # n·∫øu nh·ªè h∆°n ƒë√°p √°n hi·ªán t·∫°i th√¨ b·ªè qua
                    tm = (n - i, j + 1, i + 1, m - j)
                    for d in range(4):
                        if tm[d] > ans:
                            ans = max(ans, helper(i, j, False, d))

        return ans



# ## üöÄ √ù t∆∞·ªüng ch√≠nh c·ªßa thu·∫≠t to√°n

# * B√†i to√°n: T√¨m ƒëo·∫°n ƒë∆∞·ªùng ch√©o d√†i nh·∫•t trong ma tr·∫≠n `grid`, b·∫Øt ƒë·∫ßu t·ª´ √¥ c√≥ gi√° tr·ªã `1`, ƒëi theo ƒë∆∞·ªùng ch√©o **lu√¢n phi√™n 1 ‚Üí 2 ‚Üí 1 ‚Üí 2 ‚Ä¶**
# * C√≥ th·ªÉ ƒëi theo **4 h∆∞·ªõng ch√©o**:

#   * ‚Üò `(1,1)`
#   * ‚Üô `(1,-1)`
#   * ‚Üñ `(-1,-1)`
#   * ‚Üó `(-1,1)`
# * Trong qu√° tr√¨nh ƒëi, ta ƒë∆∞·ª£c ph√©p **r·∫Ω h∆∞·ªõng ƒë√∫ng 1 l·∫ßn** (bi·∫øn `turned` = True/False).
# * D√πng **DFS + memoization** (`functools.cache`) ƒë·ªÉ tr√°nh t√≠nh to√°n l·∫°i.

# ---

# ## üìú Code c√≥ ch√∫ th√≠ch chi ti·∫øt

# import functools
# from typing import List

# class Solution:
#     def lenOfVDiagonal(self, grid: List[List[int]]) -> int:
#         # 4 h∆∞·ªõng ch√©o
#         dirs = [(1, 1), (1, -1), (-1, -1), (-1, 1)]
#         n = len(grid)     # s·ªë h√†ng
#         m = len(grid[0])  # s·ªë c·ªôt

#         # B·∫£ng √°nh x·∫° gi√° tr·ªã k·∫ø ti·∫øp c·∫ßn c√≥
#         # grid[x][y] = 1 => c·∫ßn 2
#         # grid[x][y] = 2 => c·∫ßn 1
#         # nv[v] cho ta gi√° tr·ªã ti·∫øp theo mong mu·ªën
#         nv = [2, 2, 0]

#         @functools.cache
#         def helper(x, y, turned, dir):
#             """
#             DFS + ghi nh·ªõ
#             x, y    : v·ªã tr√≠ hi·ªán t·∫°i
#             turned  : ƒë√£ r·∫Ω h∆∞·ªõng 1 l·∫ßn ch∆∞a (True/False)
#             dir     : h∆∞·ªõng hi·ªán t·∫°i (0..3)
#             Tr·∫£ v·ªÅ ƒë·ªô d√†i ƒë∆∞·ªùng ch√©o d√†i nh·∫•t b·∫Øt ƒë·∫ßu t·ª´ (x,y)
#             """
#             res = 1  # √≠t nh·∫•t l·∫•y ƒë∆∞·ª£c √¥ (x,y)
#             dx, dy = dirs[dir]

#             # --- 1. Ti·∫øp t·ª•c ƒëi th·∫≥ng theo c√πng h∆∞·ªõng ---
#             if (0 <= x + dx < n and 0 <= y + dy < m 
#                 and grid[x + dx][y + dy] == nv[grid[x][y]]):
#                 res = helper(x + dx, y + dy, turned, dir) + 1

#             # --- 2. N·∫øu ch∆∞a r·∫Ω, th·ª≠ r·∫Ω sang h∆∞·ªõng ti·∫øp theo (90¬∞) ---
#             if not turned:
#                 ndir = (dir + 1) % 4  # quay sang h∆∞·ªõng k·∫ø ti·∫øp
#                 dx, dy = dirs[ndir]
#                 if (0 <= x + dx < n and 0 <= y + dy < m 
#                     and grid[x + dx][y + dy] == nv[grid[x][y]]):
#                     res = max(res, helper(x + dx, y + dy, True, ndir) + 1)

#             return res

#         ans = 0
#         for i in range(n):
#             for j in range(m):
#                 if grid[i][j] == 1:  # ch·ªâ b·∫Øt ƒë·∫ßu t·ª´ √¥ c√≥ gi√° tr·ªã 1
#                     # ∆∞·ªõc l∆∞·ª£ng t·ªëi ƒëa c√≥ th·ªÉ ƒëi theo m·ªói h∆∞·ªõng
#                     # n·∫øu nh·ªè h∆°n ƒë√°p √°n hi·ªán t·∫°i th√¨ b·ªè qua
#                     tm = (n - i, j + 1, i + 1, m - j)
#                     for d in range(4):
#                         if tm[d] > ans:
#                             ans = max(ans, helper(i, j, False, d))

#         return ans


# ## üîë Gi·∫£i th√≠ch c√°c b∆∞·ªõc

# 1. **B·∫Øt ƒë·∫ßu t·ª´ m·ªói √¥ c√≥ gi√° tr·ªã 1** v√¨ ƒë∆∞·ªùng ch√©o lu√¥n kh·ªüi ƒë·∫ßu b·∫±ng s·ªë 1.
# 2. V·ªõi m·ªói h∆∞·ªõng ch√©o `d`, g·ªçi `helper(i, j, False, d)` ƒë·ªÉ DFS t√¨m ƒë∆∞·ªùng d√†i nh·∫•t:

#    * N·∫øu √¥ ti·∫øp theo h·ª£p l·ªá (c√≤n trong ma tr·∫≠n v√† gi√° tr·ªã ƒë√∫ng), ƒëi ti·∫øp.
#    * N·∫øu ch∆∞a r·∫Ω (`turned = False`), th·ª≠ r·∫Ω sang h∆∞·ªõng m·ªõi.
#    * D√πng `cache` ƒë·ªÉ nh·ªõ k·∫øt qu·∫£, tr√°nh t√≠nh to√°n l·∫°i.
# 3. **Pruning (t·ªëi ∆∞u)**: tr∆∞·ªõc khi DFS, ∆∞·ªõc l∆∞·ª£ng ƒë·ªô d√†i t·ªëi ƒëa c√≥ th·ªÉ ƒëi t·ª´ √¥ `(i,j)` theo t·ª´ng h∆∞·ªõng (`tm`). N·∫øu `tm[d] <= ans` th√¨ b·ªè qua ƒë·ªÉ ti·∫øt ki·ªám th·ªùi gian.
# 4. Tr·∫£ v·ªÅ `ans` l√† chi·ªÅu d√†i ƒë∆∞·ªùng ch√©o d√†i nh·∫•t t√¨m ƒë∆∞·ª£c.

# ---

# ## ‚è±Ô∏è ƒê·ªô ph·ª©c t·∫°p

# * C√≥ `O(m*n*4*2)` tr·∫°ng th√°i (`m*n` √¥, 4 h∆∞·ªõng, turned=True/False).
# * M·ªói tr·∫°ng th√°i t√≠nh t·ªëi ƒëa 2 b∆∞·ªõc (ƒëi th·∫≥ng ho·∫∑c r·∫Ω), n√™n ƒë·ªô ph·ª©c t·∫°p **O(m\*n)**.
# * Kh√¥ng gian `O(m*n*4*2)` cho memoization.

# ---

# B·∫°n c√≥ mu·ªën m√¨nh v·∫Ω th√™m **h√¨nh minh h·ªça v√≠ d·ª• ƒë∆∞·ªùng ƒëi zigzag** ƒë·ªÉ d·ªÖ hi·ªÉu h∆°n kh√¥ng?
# Thu·∫≠t to√°n b·∫°n ƒë∆∞a ra l√† m·ªôt gi·∫£i ph√°p hi·ªáu qu·∫£ ƒë·ªÉ t√¨m ƒë∆∞·ªùng ch√©o h√¨nh ch·ªØ "V" d√†i nh·∫•t trong m·ªôt l∆∞·ªõi, s·ª≠ d·ª•ng **t√¨m ki·∫øm theo chi·ªÅu s√¢u (DFS) v√† ghi nh·ªõ (memoization)**.

# ### T·ªïng quan thu·∫≠t to√°n

# √ù t∆∞·ªüng ch√≠nh l√† duy·ªát qua m·ªçi √¥ trong l∆∞·ªõi. N·∫øu g·∫∑p m·ªôt √¥ c√≥ gi√° tr·ªã `1`, thu·∫≠t to√°n s·∫Ω b·∫Øt ƒë·∫ßu m·ªôt qu√° tr√¨nh t√¨m ki·∫øm ƒë·ªá quy ƒë·ªÉ kh√°m ph√° t·∫•t c·∫£ c√°c ƒë∆∞·ªùng ƒëi h√¨nh ch·ªØ "V" c√≥ th·ªÉ b·∫Øt ƒë·∫ßu t·ª´ ƒë√≥.

# ƒê·ªÉ tr√°nh t√≠nh to√°n l·∫°i, m·ªôt k·ªπ thu·∫≠t **ghi nh·ªõ** ƒë∆∞·ª£c s·ª≠ d·ª•ng. M·ªçi k·∫øt qu·∫£ c·ªßa c√°c b√†i to√°n con s·∫Ω ƒë∆∞·ª£c l∆∞u l·∫°i, gi√∫p ch∆∞∆°ng tr√¨nh ch·∫°y nhanh h∆°n nhi·ªÅu. Cu·ªëi c√πng, k·∫øt qu·∫£ d√†i nh·∫•t trong s·ªë t·∫•t c·∫£ c√°c ƒë∆∞·ªùng ƒëi ƒë∆∞·ª£c t√¨m th·∫•y s·∫Ω l√† c√¢u tr·∫£ l·ªùi.

# ---

# ### Ph√¢n t√≠ch chi ti·∫øt m√£ ngu·ªìn

# #### C√°c bi·∫øn v√† c·∫•u tr√∫c d·ªØ li·ªáu ch√≠nh

# * `dirs`: M·ªôt m·∫£ng tƒ©nh ch·ª©a c√°c c·∫∑p s·ªë nguy√™n, ƒë·∫°i di·ªán cho **b·ªën h∆∞·ªõng di chuy·ªÉn ch√©o**: `(1, 1)` (xu·ªëng-ph·∫£i), `(1, -1)` (xu·ªëng-tr√°i), `(-1, -1)` (l√™n-tr√°i), v√† `(-1, 1)` (l√™n-ph·∫£i).
# * `nv`: M·∫£ng `[0, 2, 1]` gi√∫p x√°c ƒë·ªãnh gi√° tr·ªã ti·∫øp theo mong ƒë·ª£i tr√™n ƒë∆∞·ªùng ƒëi.
#     * `nv[1]` l√† `2`, nghƒ©a l√† n·∫øu √¥ hi·ªán t·∫°i l√† `1`, √¥ ti·∫øp theo ph·∫£i l√† `2`.
#     * `nv[2]` l√† `1`, nghƒ©a l√† n·∫øu √¥ hi·ªán t·∫°i l√† `2`, √¥ ti·∫øp theo ph·∫£i l√† `1`.
#     * `nv[0]` kh√¥ng ƒë∆∞·ª£c s·ª≠ d·ª•ng.
# * `@functools.cache`: ƒê√¢y l√† m·ªôt decorator c·ªßa Python. N√≥ t·ª± ƒë·ªông l∆∞u k·∫øt qu·∫£ c·ªßa h√†m `helper` v√†o b·ªô nh·ªõ ƒë·ªám. N·∫øu h√†m ƒë∆∞·ª£c g·ªçi l·∫°i v·ªõi c√πng m·ªôt b·ªô tham s·ªë (`x, y, turned, dir`), n√≥ s·∫Ω tr·∫£ v·ªÅ k·∫øt qu·∫£ ƒë√£ l∆∞u m√† kh√¥ng c·∫ßn ch·∫°y l·∫°i h√†m.

# #### H√†m ƒë·ªá quy `helper(x, y, turned, dir)`

# ƒê√¢y l√† tr√°i tim c·ªßa thu·∫≠t to√°n, th·ª±c hi·ªán vi·ªác t√¨m ki·∫øm ƒë∆∞·ªùng ƒëi.

# * **Tham s·ªë**:
#     * `x, y`: T·ªça ƒë·ªô hi·ªán t·∫°i c·ªßa √¥.
#     * `turned`: M·ªôt bi·∫øn boolean (`True` ho·∫∑c `False`) cho bi·∫øt ƒë∆∞·ªùng ƒëi ƒë√£ r·∫Ω hay ch∆∞a.
#     * `dir`: H∆∞·ªõng di chuy·ªÉn hi·ªán t·∫°i.
# * **Logic**:
#     * `res = 1`: Kh·ªüi t·∫°o ƒë·ªô d√†i ƒëo·∫°n ƒë∆∞·ªùng th·∫≥ng t·ª´ √¥ hi·ªán t·∫°i l√† 1.
#     * Ki·ªÉm tra √¥ ti·∫øp theo: N√≥ t√≠nh to√°n t·ªça ƒë·ªô c·ªßa √¥ ti·∫øp theo theo h∆∞·ªõng `dir` v√† ki·ªÉm tra xem √¥ ƒë√≥ c√≥ n·∫±m trong l∆∞·ªõi v√† c√≥ gi√° tr·ªã ƒë√∫ng (`nv[grid[x][y]]`) hay kh√¥ng.
#     * N·∫øu h·ª£p l·ªá, n√≥ g·ªçi ƒë·ªá quy `helper` cho √¥ ti·∫øp theo v√† c·ªông th√™m 1 v√†o k·∫øt qu·∫£.
#     * Ki·ªÉm tra r·∫Ω: `if not turned`: N·∫øu ƒë∆∞·ªùng ƒëi **ch∆∞a** r·∫Ω, n√≥ s·∫Ω th·ª≠ m·ªôt h∆∞·ªõng m·ªõi (h∆∞·ªõng ti·∫øp theo trong `dirs`).
#         * N√≥ ki·ªÉm tra √¥ ti·∫øp theo sau khi r·∫Ω.
#         * N·∫øu h·ª£p l·ªá, n√≥ g·ªçi ƒë·ªá quy `helper` v·ªõi tham s·ªë `turned` ƒë∆∞·ª£c ƒë·∫∑t l√† `True` (v√¨ ƒë∆∞·ªùng ƒëi ƒë√£ r·∫Ω).
#         * N√≥ so s√°nh k·∫øt qu·∫£ c·ªßa ƒë∆∞·ªùng ƒëi th·∫≥ng v√† ƒë∆∞·ªùng ƒëi r·∫Ω, l·∫•y gi√° tr·ªã l·ªõn nh·∫•t v√† c·∫≠p nh·∫≠t v√†o `res`.

# #### V√≤ng l·∫∑p ch√≠nh v√† c√°c t·ªëi ∆∞u h√≥a

# * V√≤ng l·∫∑p `for i in range(n)` v√† `for j in range(m)`: Thu·∫≠t to√°n duy·ªát qua t·ª´ng √¥ trong l∆∞·ªõi.
# * `if grid[i][j] == 1`: Ch·ªâ b·∫Øt ƒë·∫ßu t√¨m ki·∫øm t·ª´ nh·ªØng √¥ c√≥ gi√° tr·ªã `1`.
# * **T·ªëi ∆∞u h√≥a**:
#     * `tm = (n - i, j + 1, i + 1, m - j)`: M·∫£ng n√†y t√≠nh to√°n ƒë·ªô d√†i **t·ªëi ƒëa l√Ω thuy·∫øt** c·ªßa m·ªôt ƒë∆∞·ªùng ƒëi th·∫≥ng t·ª´ √¥ `(i, j)` ƒë·∫øn bi√™n c·ªßa l∆∞·ªõi theo m·ªói h∆∞·ªõng.
#     * `if tm[d] > ans`: Tr∆∞·ªõc khi g·ªçi ƒë·ªá quy `helper`, thu·∫≠t to√°n ki·ªÉm tra xem ƒë·ªô d√†i l√Ω thuy·∫øt c√≥ l·ªõn h∆°n k·∫øt qu·∫£ t·ªët nh·∫•t hi·ªán t·∫°i (`ans`) hay kh√¥ng. N·∫øu kh√¥ng, n√≥ s·∫Ω b·ªè qua cu·ªôc g·ªçi ƒë·ªá quy ƒë√≥, gi√∫p ti·∫øt ki·ªám th·ªùi gian ƒë√°ng k·ªÉ.
#     * `ans = max(ans, helper(i, j, False, d))`: K·∫øt qu·∫£ c·ªßa h√†m `helper` l√† ƒë·ªô d√†i c·ªßa ƒëo·∫°n ƒë∆∞·ªùng sau √¥ b·∫Øt ƒë·∫ßu. Do ƒë√≥, ch√∫ng ta kh√¥ng c·∫ßn c·ªông th√™m 1 v√†o ƒë√¢y. (L∆∞u √Ω: C√°ch tri·ªÉn khai n√†y h∆°i kh√°c v·ªõi phi√™n b·∫£n Java, n∆°i `dfs` tr·∫£ v·ªÅ ƒë·ªô d√†i ƒëo·∫°n ƒë∆∞·ªùng sau √¥ ƒë·∫ßu ti√™n v√† c·∫ßn c·ªông th√™m 1 sau khi g·ªçi).